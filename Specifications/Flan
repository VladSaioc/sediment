domain Values := [
  vconst[Fcon] +
  vpair[Values * Values] +
  cloj[Symbol * Fexp * Env] +
  rcloj[Symbol * Symbol * Fexp * Env]
];

domain Env := Symbol -> Values;

let freshEnv := \ Symbol: x . _/Values\_;

let apply := \ Fcon : f. \ Values : x.
  vconst[
    if x is vpair then
      let x' := x >> vpair in
      let x1' := (<) x' in
      if !(x1' is vconst) then _/Fcon\_
      else let x1 := x1' >> vconst in
      let x2' := (>) x' in
      if !(x2' is vconst) then _/Fcon\_
      else let x2 := x2' >> vconst in
      if f is plus
      then number[x1 >> number + x2 >> number]
      else if f is minus
      then number[x1 >> number - x2 >> number]
      else if f is times
      then number[x1 >> number * x2 >> number]
      else if f is equal
      then if x1 is number & x2 is number
        then bconst[x1 >> number == x2 >> number]
        else if x1 is bconst & x2 is bconst
          then bconst[x1 >> bconst == x2 >> bconst]
          else _/Fcon\_
      else _/Fcon\_
    else if x is vconst
    then let x' := x >> vconst in
      if x' is bconst
      then if f is not
        then bconst[!(x' >> bconst)]
        else _/Fcon\_
      else if x' is number
      then if f is is0
        then bconst[x' >> number == 0]
        else _/Fcon\_
      else _/Fcon\_
    else _/Fcon\_
  ];
  
syntax Fexp := var of Symbol
  | const of Fcon
  | pair of Fexp * Fexp
  | app of Fexp * Fexp
  | iff of Fexp * Fexp * Fexp
  | fn of Symbol * Fexp
  | letnr of Symbol * Fexp * Fexp
  | letr of Symbol * Fexp * Fexp;

syntax Fcon := number of Int
  | bconst of Bool
  | plus | times | minus | equal | not | is0;

system Env |- Fexp ==> Values : Fexp :=
  [ VAR ]: env |- var[x] ==> env(x);
  
  [ CONST ]: env |- const[c] ==> vconst[c];
  
  [ PAIR ]: env |- pair[e1, e2] ==> vpair[v1, v2] \\
    env |- e1 ==> v1,
    env |- e2 ==> v2;
  
  [ APP ]: env |- app[e1, e2] ==> v \\
    env |- e1 ==> cloj[x, e, env'],
    env |- e2 ==> v',
    [x -> v']env' |- e ==> v;
  
  [ APP ]: env |- app[e1, e2] ==> apply(c)(v2) \\
    env |- e1 ==> vconst[c],
    env |- e2 ==> v2;

  [ APP ]: env |- app[e1, e2] ==> v \\
    env |- e1 ==> rcloj[f, x, e, env'],
    env |- e2 ==> v',
    let rclojure := rcloj[f, x, e, env'],
    [x -> v'][f -> rclojure]env' |- e ==> v;

  [ IF ]: env |- iff[b, e1, e2] ==> v \\
    env |- b ==> vconst[bconst[true]],
    env |- e1 ==> v;
  
  [ IF ]: env |- iff[b, e1, e2] ==> v \\
    env |- b ==> vconst[bconst[false]],
    env |- e2 ==> v;
  
  [ FN ]: env |- fn[x, e] ==> cloj[x, e, env];
  
  [ LET ]: env |- letnr[x, e1, e2] ==> v \\
    env |- e1 ==> v',
    [x -> v']env |- e2 ==> v;
  
  [ LETREC ]: env |- letr[f, e1, e2] ==> v \\
    env |- e1 ==> cloj[x, e, env'],
    [f -> rcloj[f, x, e, env']]env |- e2 ==> v;
end

evaluate [`y` -> vconst[number[5 % 2]]]freshEnv |- app[
  fn[`x`,
    app[
      const[plus[]],
      pair[
        var[`x`],
        const[number[5]]
      ]
    ]
  ],
  var[`y`]
] in Fexp;